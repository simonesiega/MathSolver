#[allow(unused)]
use std::io::{self, Write};

#[cfg(debug_assertions)]
macro_rules! trace_log { ($($arg:tt)*) => { log::trace!($($arg)*); }; }

#[cfg(debug_assertions)]
macro_rules! debug_log { ($($arg:tt)*) => { log::debug!($($arg)*); }; }

#[cfg(debug_assertions)]
macro_rules! info_log { ($($arg:tt)*) => { log::info!($($arg)*); }; }

#[cfg(debug_assertions)]
macro_rules! warn_log { ($($arg:tt)*) => { log::warn!($($arg)*); }; }

#[cfg(debug_assertions)]
macro_rules! error_log { ($($arg:tt)*) => { log::error!($($arg)*); }; }

#[cfg(not(debug_assertions))]
macro_rules! trace_log { ($($arg:tt)*) => {}; }

#[cfg(not(debug_assertions))]
macro_rules! debug_log { ($($arg:tt)*) => {}; }

#[cfg(not(debug_assertions))]
macro_rules! info_log { ($($arg:tt)*) => {}; }

#[cfg(not(debug_assertions))]
macro_rules! warn_log { ($($arg:tt)*) => {}; }

#[cfg(not(debug_assertions))]
macro_rules! error_log { ($($arg:tt)*) => {}; }



#[derive(Debug, Clone, Copy, PartialEq)]
enum Token {
    Number(f64),
    Plus,
    Minus,
    Multiply,
    Divide,
    LeftParen,
    RightParen,
    Equals,
}

impl Token {
    #[inline]
    fn from_char(c: char) -> Option<Self> {
        match c {
            '+' => Some(Token::Plus),
            '-' => Some(Token::Minus),
            '*' => Some(Token::Multiply),
            '/' => Some(Token::Divide),
            '(' => Some(Token::LeftParen),
            ')' => Some(Token::RightParen),
            '=' => Some(Token::Equals),
            _ => None,
        }
    }

    #[allow(unused)]
    #[inline]
    fn is_operator(&self) -> bool {
        matches!(self, Token::Plus | Token::Minus | Token::Multiply | Token::Divide)
    }
}

#[derive(Debug, PartialEq)]
#[allow(unused)]
enum MathError {
    DivisionByZero,
    OverflowError,
    UnderflowError,
    ExpressionTooComplex,
}

#[derive(Debug, PartialEq)]
#[allow(unused)]
enum TokenError {
    InvalidNumber(String),
    MissingParenthesis(usize),
    UnexpectedEnd,
    InvalidExpression(String),
    InvalidOperator(char),
    UnmatchedParentheses,
    UnexpectedToken(Token),
    SyntaxError(String),
}

// Implementazione Display per MathError
impl std::fmt::Display for MathError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            MathError::DivisionByZero => {
                error_log!("Tentativo di divisione per zero");
                write!(f, "Errore matematico: divisione per zero")
            },
            MathError::OverflowError => {
                error_log!("Overflow numerico rilevato");
                write!(f, "Errore matematico: il risultato è troppo grande")
            },
            MathError::UnderflowError => {
                error_log!("Underflow numerico rilevato");
                write!(f, "Errore matematico: il risultato è troppo piccolo")
            },
            MathError::ExpressionTooComplex => {
                error_log!("Espressione troppo complessa da valutare");
                write!(f, "Errore: espressione troppo complessa")
            },
        }
    }
}

// Implementazione Display per TokenError
impl std::fmt::Display for TokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            TokenError::InvalidNumber(msg) => {
                warn_log!("Numero non valido: {}", msg);
                write!(f, "Numero non valido: {}", msg)
            },
            TokenError::MissingParenthesis(pos) => {
                warn_log!("Parentesi mancante alla posizione {}", pos);
                write!(f, "Parentesi mancante alla posizione {}", pos)
            },
            TokenError::UnexpectedEnd => {
                error_log!("Espressione terminata inaspettatamente");
                write!(f, "Espressione terminata inaspettatamente")
            },
            TokenError::InvalidExpression(msg) => {
                error_log!("Espressione non valida: {}", msg);
                write!(f, "Espressione non valida: {}", msg)
            },
            TokenError::InvalidOperator(op) => {
                warn_log!("Operatore non valido: {}", op);
                write!(f, "Operatore non valido: {}", op)
            },
            TokenError::UnmatchedParentheses => {
                warn_log!("Parentesi non bilanciate nell'espressione");
                write!(f, "Errore di sintassi: parentesi non bilanciate")
            },
            TokenError::UnexpectedToken(token) => {
                warn_log!("Token inatteso: {:?}", token);
                write!(f, "Token inatteso: {:?}", token)
            },
            TokenError::SyntaxError(msg) => {
                error_log!("Errore di sintassi: {}", msg);
                write!(f, "Errore di sintassi: {}", msg)
            }
        }
    }
}

impl std::error::Error for MathError {}
impl std::error::Error for TokenError {}

// Definizione di un tipo Result personalizzato che può gestire entrambi i tipi di errore
#[derive(Debug)]
#[derive(PartialEq)]
enum CalcError {
    Math(MathError),
    Token(TokenError),
}

impl From<MathError> for CalcError {
    fn from(error: MathError) -> Self {
        CalcError::Math(error)
    }
}

impl From<TokenError> for CalcError {
    fn from(error: TokenError) -> Self {
        CalcError::Token(error)
    }
}

impl std::fmt::Display for CalcError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            CalcError::Math(e) => write!(f, "Errore matematico: {}", e),
            CalcError::Token(e) => write!(f, "Errore di tokenizzazione: {}", e),
        }
    }
}

// Implementazione Error per CalcError
impl std::error::Error for CalcError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            CalcError::Math(e) => Some(e),
            CalcError::Token(e) => Some(e),
        }
    }
}


type CalcResult = Result<f64, CalcError>;

struct Tokenizer<'a> {
    input: &'a str,
    position: usize,
}

impl<'a> Tokenizer<'a> {
    fn new(input: &'a str) -> Self {
        info_log!("Creazione nuovo tokenizer con input: {}", input);
        Self {
            input,
            position: 0,
        }
    }

    fn tokenize(&mut self) -> Result<Vec<Token>, TokenError> {
        info_log!("Inizio tokenizzazione");
        let mut tokens = Vec::new();

        while self.position < self.input.len() {
            let c = self.current_char();
            match c {
                c if c.is_whitespace() => {
                    self.advance();
                }
                c if c.is_ascii_digit() || c == '.' => {
                    let token = self.parse_number()?;
                    trace_log!("Token numerico trovato: {:?}", token);
                    tokens.push(token);
                }
                c => {
                    if let Some(token) = Token::from_char(c) {
                        trace_log!("Token operatore trovato: {:?}", token);
                        tokens.push(token);
                        self.advance();
                    }
                    else {
                        return Err(TokenError::InvalidOperator(c));
                    }
                }
            }

        }
        
        info_log!("Tokenizzazione completata. Tokens: {:?}", tokens);
        Ok(tokens)
    }

    fn parse_number(&mut self) -> Result<Token, TokenError> {
        let start = self.position;
        let mut has_decimal = false;

        while self.position < self.input.len() {
            match self.current_char() {
                c if c.is_ascii_digit() => {
                    self.advance();
                }
                '.' if !has_decimal => {
                    has_decimal = true;
                    self.advance();
                }
                '.' => return Err(TokenError::InvalidNumber(
                    "Troppi punti decimali".to_string()
                )),
                _ => break,
            }
        }


        let number_str = &self.input[start..self.position];
        number_str.parse::<f64>()
            .map(Token::Number)
            .map_err(|_| TokenError::InvalidNumber(number_str.to_string()))
    }

    #[inline]
    fn current_char(&self) -> char {
        self.input[self.position..].chars().next().unwrap()
    }

    #[inline]
    fn advance(&mut self) {
        self.position += 1;
    }
}

struct MathExpressionParser {
    tokens: Vec<Token>,
    position: usize,
}

impl MathExpressionParser {
    fn new(tokens: Vec<Token>) -> Self {
        info_log!("Creazione nuovo parser con tokens: {:?}", tokens);
        Self {
            tokens,
            position: 0,
        }
    }

    #[inline]
    fn check_overflow(&self, result: f64) -> Result<f64, MathError> {
        if result.is_infinite() {
            Err(MathError::OverflowError)
        } else if result.is_subnormal() {
            Err(MathError::UnderflowError)
        } else {
            Ok(result)
        }
    }

    fn evaluate(&mut self) -> CalcResult {
        info_log!("Inizio valutazione espressione");
        let result = self.evaluate_expression()?;

        match self.peek() {
            Some(&Token::Equals) => {
                info_log!("Espressione valutata correttamente: {}", result);
                Ok(result)
            }
            Some(token) => Err(TokenError::UnexpectedToken(*token).into()),
            None => Err(TokenError::UnexpectedEnd.into()),
        }
    }

    fn evaluate_expression(&mut self) -> CalcResult {
        debug_log!("Valutazione espressione alla posizione: {}", self.position);
        let mut result = self.evaluate_term()?;

        while let Some(token) = self.peek() {
            match *token {
                Token::Plus => {
                    self.advance();
                    let term = self.evaluate_term()?;
                    trace_log!("Addizione: {} + {}", result, term);
                    result = self.check_overflow(result + term).map_err(CalcError::Math)?;
                }
                Token::Minus => {
                    self.advance();
                    let term = self.evaluate_term()?;
                    trace_log!("Sottrazione: {} - {}", result, term);
                    result = self.check_overflow(result - term).map_err(CalcError::Math)?;
                }
                _ => break,
            }
        }
        Ok(result)
    }

    fn evaluate_term(&mut self) -> CalcResult {
        debug_log!("Valutazione termine alla posizione: {}", self.position);
        let mut result = self.evaluate_factor()?;

        while let Some(token) = self.peek() {
            match *token {
                Token::Multiply => {
                    self.advance();
                    let factor = self.evaluate_factor()?;
                    trace_log!("Moltiplicazione: {} * {}", result, factor);
                    result = self.check_overflow(result * factor).map_err(CalcError::Math)?;
                }
                Token::Divide => {
                    self.advance();
                    let factor = self.evaluate_factor()?;

                    if factor == 0.0 {
                        return Err(MathError::DivisionByZero.into());
                    }

                    trace_log!("Divisione: {} / {}", result, factor);
                    result = self.check_overflow(result / factor).map_err(CalcError::Math)?;
                }
                _ => break,
            }
        }
        Ok(result)
    }

    fn evaluate_factor(&mut self) -> CalcResult {
        debug_log!("Valutazione fattore alla posizione: {}", self.position);
        match self.next() {
            Some(Token::Number(n)) => Ok(n),
            Some(Token::Minus) => {
                let value = self.evaluate_factor()?;
                trace_log!("Negazione: -{}", value);
                Ok(-value)
            }
            Some(Token::LeftParen) => {
                let result = self.evaluate_expression()?;
                match self.next() {
                    Some(Token::RightParen) => {
                        trace_log!("Parentesi valutata: ({})", result);
                        Ok(result)
                    }
                    _ => Err(TokenError::MissingParenthesis(self.position).into()),
                }
            }
            _ => Err(TokenError::InvalidExpression("Espressione non valida".to_string()).into()),
        }
    }


    #[inline]
    fn peek(&self) -> Option<&Token> {
        self.tokens.get(self.position)
    }

    #[inline]
    fn next(&mut self) -> Option<Token> {
        if self.position < self.tokens.len() {
            let token = self.tokens[self.position];
            self.position += 1;
            Some(token)
        } else {
            None
        }
    }

    #[inline]
    fn advance(&mut self) {
        self.position += 1;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_division_by_zero() {
        let expression = "((8-9.81*3.14)-.12*(1*9/2.3)+-5.17) / 0=";
        let mut tokenizer = Tokenizer::new(expression);
        let tokens = tokenizer.tokenize().unwrap();
        let mut parser = MathExpressionParser::new(tokens);
        println!("{:?}", parser.evaluate());
    }
    
    #[test]
    fn test_invalid_number_multiple_dots() {
        let expression = "1..2 + 3";
        let mut tokenizer = Tokenizer::new(expression);
        println!("{:?}", tokenizer.tokenize());
    }

    #[test]
    fn test_unexpected_end() {
        let expression = "5 + (3 * 2";
        let mut tokenizer = Tokenizer::new(expression);
        let tokens = tokenizer.tokenize().unwrap();
        let mut parser = MathExpressionParser::new(tokens);
        println!("{:?}", parser.evaluate());
    }

    #[test]
    fn test_invalid_expression() {
        let expression = "+ 5 =";
        let mut tokenizer = Tokenizer::new(expression);
        let tokens = tokenizer.tokenize().unwrap();
        let mut parser = MathExpressionParser::new(tokens);
        println!("{:?}", parser.evaluate());
    }

    #[test]
    fn test_unmatched_parentheses_simulated() {
        let expression = "((1+2))))) =";
        let mut tokenizer = Tokenizer::new(expression);
        let result = tokenizer.tokenize();
        let tokens = result.unwrap();
        let mut parser = MathExpressionParser::new(tokens);
        println!("{:?}", parser.evaluate());
    }

    #[test]
    fn test_unexpected_token() {
        let expression = "1 + * 2 =";
        let mut tokenizer = Tokenizer::new(expression);
        let tokens = tokenizer.tokenize().unwrap();
        let mut parser = MathExpressionParser::new(tokens);
        println!("{:?}", parser.evaluate());
    }
}



fn main() -> Result<(), Box<dyn std::error::Error>> {
    #[cfg(debug_assertions)]
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("debug")).init();

    let input = "((8-9.81*3.14)-.12*(1*9/2.3)+-5.17) / 0=";
    info_log!("Input espressione: {}", input);

    let mut tokenizer = Tokenizer::new(input);
    let tokens = tokenizer.tokenize()?;
    let mut parser = MathExpressionParser::new(tokens);
    
    match parser.evaluate() {
        Ok(result) => {
            println!("Risultato: {:.3}", result);
            Ok(())
        }
        Err(e) => {
            println!("Errore: {}", e);
            Err(Box::new(e))
        }
    }
}